---
title: DDIA-数据编码与演化
data: 2024-07-29
cover: /img/blog/blog14.jpg
categories:
- 大数据
tags:
- database
- Distributed computing
---

应用程序不可避免地需要随时间而变化，在演化过程中，需要不断地添加或修改功能。在大多数情况下，更改应用程序功能时，也需要更改其存储的数据: 可能需要捕获新的字段或记录类型，或者需要以新的方式呈现已有数据。

当数据格式发生变化时，经常需要对应用程序代码进行相应的调整(例如，向记录中添加新字段，然后应用程序代码开始读取和写入该字段) 。然而，对于一个大型应用系统，代码更迭往往并非易事。
1. 服务器端程序，可能需要滚动升级，每次将新版本部署到少数几个节点，之后再逐步推广到所有节点。
2. 对于客户端应用程序，用户可能不会在一段时间内马上更新软件

这意为着新旧版本的代码，以及新旧数据格式，可能同时在系统中共存，所以保证数据的双向兼容性至关重要

<!--more-->

## 数据兼容性

1. 向后兼容性\
   较新的代码可以读取由旧代码编写的数据
2. 向前兼容性\
   较旧的代码可以读取新代码编写的数据

向后兼容通常不难实现：只需要清楚旧代码所编写的数据格式，就可以比较明确的处理这些数据，对于向前兼容性，旧的代码需要忽略新版本代码中所做的添加

在本文中，将介绍多种编码数据的格式，包括JSON、XML、Protocol Buffers、Thrift。特别地，我们将讨论它们如何处理模式变化，以及保证兼容性。之后，还将讨论这些格式如何用于数据存储和通信场景，包括在Web服务中，具象状态传输 (Representational State Transfer，REST) 和远程过程调用 (remote procedure calls，RPC) 以及消息传递系统，如actors和消息队列。

## 数据编码

程序通常使用两种不同的数据表示形式:

1. 在内存中,数据保存在对象、结构体、列表、数组、哈希表和树等结构中。这些数据结构针对CPU的高效访问和操作进行了优化(通常使用指针) 。

2. 将数据写和入文件或通过网络发送时，必须将其编码为某种自包含的字节序列(例如 JSON文档) 。由于指针对其他进程没有意义，所以这个字节序列表示看起来与内存中使用的数据结构大不一样。

因此，这两种表示之间需要进行类型的转化。从内存中的表示到字节序列的转化称为编码(或序列化等) ，相反的过程称为解码 (或解析，反序列化)。

### 语言特定的编码
多数编程语言，如Java、Ruby、Python等，通过内置库（例如Java的java.io.Serializable，Ruby的Marshal，Python的pickle）支持内存对象的编码。

这些库使得保存和恢复内存中的对象变得非常简单，仅需少量代码。但是却面临这一些问题与挑战：
1. 编码与特定语言绑定：编码过程通常依赖于特定的编程语言，这使得使用其他语言访问编码数据变得困难，不利于跨语言或跨系统集成。
2. 安全风险：解码过程可能允许实例化任意类，这可能导致安全漏洞，如远程执行代码。
3. 版本兼容性问题：这些库通常忽略了数据的多版本兼容性，主要关注于数据编码的速度和简便性。
4. 效率问题：编解码的CPU效率和编码结构的大小通常被忽视，特别是Java内置序列化因其性能不佳和庞大的编码结构而被批评。

尽管内置和第三方编码库在使用上非常方便，但由于上述问题，除非是临时尝试，语言内置的编码方案通常不是一个好方案。

### JSON、XML与二进制变体

目标转向可由不同编程语言编写和读取的标准化编码，`JSON` 因为简单性以及在浏览器中内置支持而流行，并且它是javaScript的子集，`XML` 尽管被批评为复杂和冗长，但仍广泛使用。`CSV` 简单但功能有限，适用于基础数据表达。

JSON、XML和CSV都是文本格式，因此具有不错的可读性 (尽管语法容易引发争论) 。除了表面的语法问题之外，它们也有一些微妙的问题:

1. 数字编码模糊性：XML和CSV难以区分数字和字符串；JSON区分数字和字符串，但不区分整数和浮点数，也不指定精度。
2. 二进制数据不支持：JSON和XML不支持原生二进制数据，通常通过Base64编码解决，但这增加了数据大小和复杂性。
3. 模式支持：XML和JSON的模式支持可选且复杂，而CSV完全没有模式支持，需手动管理数据结构的变化。
```txt
XML使用XSD（XML Schema Definition）定义模式。XSD定义了XML文档的结构、元素和属性。

JSON模式（JSON Schema）定义了JSON数据的结构，包括哪些字段是必须的，它们的类型是什么，以及如何验证字段的值。
```

```json
// json 数据
{
    "name": "Alice",
    "age": 30
}
```

```json
// JSON模式
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "name": {
      "type": "string"
    },
    "age": {
      "type": "integer"
    }
  },
  "required": ["name", "age"]
}
```

尽管存在这些或那些缺陷，但JSON、XML和CSV已经可用于很多应用。特别是作为数据交换格式 (即将数据从一个组织发送到另一个组织)。

### 二进制编码

对于一个小的数据集来说，传输、解析的收益可以忽略不计，但一旦数据规模到达TB级别，就需要尽可能的压缩数据规模。减少编码大小。

对于特定的数据类型，上面的文本数据编码都不能很好的支持，所以需要一种支持不同数据类型的编码格式

为了解决上述的问题，来分析不同二进制编码之间是如何处理的

![](../../img/blogs/DDIA/四/1.png)

首先给出一个 JSON 编码的示例，后文将与该编码进行比对，看看不同编码格式的差异

#### Thrift 与 Protocol Buffers

`Apache Thrift` 和 `Protocol Buffers (protobuf)` 是基于相同原理的两种二进制编码库。Protocol Buffers 最初是在 Google 开发的，Thrift 最初是在 Facebook 开发的，二者都是开源的。

Thrift 和 Protocol Buffers 都需要模式来编码任意的数据。可以使用Thrift接口定义语言 (IDL) 来描述模式，如下所示：
```Thrift
struct Person {
    1 : required string userName，
    2 : optional i64 favoriteNumber，
    3 : optional list<string> interests
}
```
Protocol Buffers的等价模式定义看起来非常相似:
```protobuf
message Person {
    required string user_name       = 1;
    optional int64 favoTrite_number = 2;
    repeated string interests       = 3;
}
```

这两种数据编码通过在定义模式中指定数据类型来实现对不同数据的正确编码

那么这个模式编码的数据是什么样的呢？ Thrift 有着两种不同的二进制编码格式，分别称为 `BinaryProtocoal` 与 `CompactProtocal` 

先来看看 BinaryProtocol，这种格式编码需要59字节

![](../../img/blogs/DDIA/四/2.png)

可以发现这种编码格式没有字段名 (userName、favoriteNumber和
interest) 。相反，确实包含这对应的数字标签(1、2和3),字段标签就像字段的别名，用来指示当前的字段，但更为紧凑。

Thrift CompactProtocol编码在语义上等同于BinaryProtocol，除了数字标签，还使用了变长数组来实现

![](../../img/blogs/DDIA/四/3.png)

最后，Protocol Buffers (只有一种二进制编码格式) 对相同的数据进行编码。它的位打包方式略有不同，但与Thrift的 CompactProtocol 非常相似

![](../../img/blogs/DDIA/四/4.png)

#### 模式演化

之前说过，模式不可避免地需要随着时间而不断变化，称之为`模式演化`。那么 Thrift 和 Protocol Buffers 如何在保持向后和向前兼容性的同时应对模式更改呢?

每个字段在模式中通过唯一的标签号（field tag）来识别，而不是字段名称，确保了数据的兼容性和一致性。

向前兼容性:
- 字段的添加：可以向模式中添加新字段，赋予新的标签号。如果旧代码遇到未知的标签号，它会忽略这些新字段。这是通过让解析器跳过特定的字节数来实现的，允许旧代码读取新代码写入的数据。
- 删除字段：可以删除可选字段，这样旧代码即使读不到，也可也根据设置使用一个默认值或者简单忽略，如果是必选字段，则会因读不到值而报错
- 更改数据类型：更改字段的数据类型是可能的，但要注意数据可能丢失精度或被截断的风险。例如，将32位整数改为64位整数时，旧代码可能无法处理新数据的完整范围。

向后兼容性：
- 字段的读取：新代码总能读取旧数据，因为每个字段的标签号意义不变。但新添加的字段不能设置为必填（required），因为这会导致新代码在读取旧数据时失败，旧数据中不包含新字段。
- 删除字段：新代码遇到已经删除的字段，它会忽略这些新字段
- 更改数据类型：同向前兼容性一样，肯发生丢失精度或被截断的风险